import { RuleElement } from "@/lib/types";
import { RuleElementCategories } from "./schema-data";

type WalkingDeadRuleElement = RuleElement<typeof RuleElementCategories>;

export const UsingSkill = {
  id: "using-skill",
  name: "使用技能",
  originalName: "Using Skill",
  category: "core/rule/skills-and-talents",
  description: "使用技能的規則。",
  order: 1,
  type: "rule",
  rows: [
    {
      rowId: "base",
      defaultRows: [
        [
          "基礎",
          "共有 12 項技能，與特定屬性連結，用於應對困難情境。技能使用時，將技能等級與相關屬性值相加，決定六面骰骰池數。有壓力點時，每點壓力增加一顆壓力骰。擲出的六代表成功，大多數技能檢定只需一次成功。",
        ],
      ],
    },
    {
      rowId: "adding-modifier",
      defaultRows: [
        [
          "增加修正值",
          "基本上，將所有影響擲骰的因素加起來。如果你有天賦或物品，使擲骰增加+2，並且有人協助你，提供額外+1的獎勵，你就可以總共增加三顆額外的骰子來擲骰。在少見的情況下，你可能會減少基礎骰的數量。",
        ],
      ],
    },
    {
      rowId: "means-and-ends",
      defaultRows: [
        [
          "目的和手段",
          "在進行技能擲骰之前，必須描述你的PC試圖達成什麼目標。GM可能會要求進一步解釋或更改目標。這通常發生在他們無法清晰了解你的目標，或認為你的目標不切實際時。例如，無法使用潛行技能來偷偷繞過已經看到你的守衛。",
        ],
      ],
    },
    {
      rowId: "failed-tests",
      defaultRows: [
        [
          "失敗的檢定",
          "技能檢定失敗意味著未達到想要的結果。例如，試圖爬過圍欄逃離行者時，可能被抓住腳拉回；試圖激勵他人拿起武器時，他們可能會猶豫不決；在野外建立營地失敗，可能會遭受行者無預警的攻擊或因雨淋濕所有補給。有時，GM可能允許你在失敗時也能部分達成目標，例如一些NPC同意戰鬥，或者設法逃脫但留下可被追踪的痕跡。",
        ],
      ],
    },
    {
      rowId: "pushing-the-roll",
      defaultRows: [
        [
          "強推擲骰",
          "當你失敗一次檢定時，你可以選擇再試一次，這被稱為重新擲骰。你可能找到了另一種達成目標的方式，或是僅僅動員了你最後的力量和決心。如果你無法解釋你的PC如何做到再次嘗試，你就不被允許重新擲骰。一個特定的擲骰只能重新擲骰一次。當你重新擲骰時，你重新擲那些非成功的骰子。你也會獲得一個壓力點，並在重新擲骰時增加一個壓力骰。即使已經成功，你也可以重新擲骰，因為有些情況下需要多次成功。",
        ],
      ],
    },
    {
      rowId: "stress-dice",
      defaultRows: [
        [
          "壓力骰",
          "遊戲中的恐怖、危險或緊張情況可以使你的角色遭受壓力，以壓力點的形式出現。每次你強推技能擲骰時，你也會獲得一個壓力點。無論情況有多壓力，你一次永遠只會獲得一個壓力點。壓力因素表指出了會導致你獲得壓力的典型情況。對於你累積的每一點壓力，你都會在任何技能擲骰時增加一個壓力骰。這不是可選的。壓力使你更加專注，更傾向於成功完成你正在做的事。然而，它也使你更有可能犯錯。在壓力骰上擲出1被稱為“擲出行者”。這意味著兩件事：如果你還沒有這樣做，你不能推動擲骰，而你會搞砸。即使擲骰成功，你仍有可能搞砸 - 你得到了你想要的，但其他事情出了問題。無論你在壓力骰上擲出一個還是多個行者，搞砸的效果都是相同的。",
        ],
      ],
    },
  ],
} as const satisfies WalkingDeadRuleElement;
